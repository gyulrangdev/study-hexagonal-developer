# 테스트

## 테스트 코드

이 책의 저자는 테스트 주도 개발 가장 도움이 많이 된 것 중 하나라고 말하고있다.

### 자동화된 테스트, 회귀 테스트, 안정감

크고 복잡한 시스템에서 기존 코드를 수정하는 것 -> 두려움

테스트 코드가 있다면 QA 담당자를 기다릴 필요 없이 개발자가 직접 실행하고 결과를 확인할 수 있다.

테스트 커버리지 : 테스트가 검증하는 범위

테스트 커버리지 높을 수록 수정한 코드가 문제를 일으키지 않은 거란 확인도 커진다.

> 테스트 커버리지에 집착하지 말기
> 테스트 커버리지는 70~80% 정도면 적당하다
> 커버리지가 높을 수록 좋지만 90% 이상을 목표로하면 만들지 않아도 될 테스트 코드를 작성하는 일이 벌어진다.
> ex. Member 클래스의 getLastUpdate() 같은 메스드를 테스트 코드로 만드는 식
> 가치 있는 테스트 코드만 만들자.

자동화된 테스트가 있으면 회귀 테스트를 쉽게 진행할 수 있다.

- 회귀 테스트(regression test): 수정한 기능 외에 다른 기능에 영향이 없는지 검증하는 테스트

자동화 테스트가 있다면 심각한 오류를 사전에 발견해서 고칠 수 있다.

통합 테스트를 수행하는 작업을 젠킨스에 등록하고, 매일 정해진 시간에 토앟ㅂ 테스트를 실행하여 전체 테스트 를 통과하지 못하면 푸시로 알림을 보내도록 설정한다.

테스트 코드는 잘못된 코드가 배포될 가능성을 낮춘다.

### 테스트 주도 개발과 회귀 테스트

테스트 주도 개발 (Test-Driven Development, TDD) : 테스트 코드를 먼저 만들고 그 다음 테스트를 통과하기 위해 구현을 진행

예외적인 상황에서의 테스트를 먼저 작성하고, 그 다음 정상적인 상황에서의 테스트를 작성하는게 좋다.

ex. 회원 암호 변경 기능을 구현할 때 회원이 존재하지 않거나 이전 암호와 새로운 암호가 일치하지 않을 때 같이 예외 상황에 대한 테스트 코드를 먼저 작성한다.

예외적인 상황에 대한 테스트 코드를 작성하면 테스트가 다루는 커버리지가 높아진다.

### 테스트 주도 개발과 설계

TDD는 기능을 설계하는데 도움을 준다.

테스트 코드에서 테스트할 대상의 기능을 실행하여며녀 다음과 같은 것들이 정의 되어야한다.

- 클래스(타입) 이름
- 메서드 이름
- 메서드 파라미터 타입
- 라턴 타입, 익셉션 타입
- 의존 대상, 역할

이들을 결정하는 과정에서 직접 기능을 구현하는 것이 아니라 다른 타입에 구현을 미루는 형태로 역할을 분리할 수도 있다. 이런 과정이 모두 설계에 해당한다.

### 테스트 주도 개발과 생산성

테스트 코드 작성 경험이 없는 개발자는 테스트 코드를 작성하는 자체가 생산성이 떨어지는 일이라고 느낄 수 있다.
if 조건을 아주 조금만 변경하면 되는데 테스트 코드까지 함께 수정하다보면 시간이 배로 소요된다. 상황에 따라 테스트 코드를 작성하는데 더 많은 노력이 들기도 한다.

하지만 전체적 개발 관점에서 보면 이야기가 다르다.
웹 API를 개발한다고 하면, API 요청 처리(컨트롤러), 로직(서비스), 모델, 데이터베이스 연동(SQL)에 대한 코드를 한번에 작성한 다음 테스트를 진행한다.

코드를 수정해서 확인하고 잘못된 곳이 발견되면 또 코드를 수정해서 확인하는 과정을 반복적으로 거쳐야한다.
수동으로 테스트할 때는 다양한 예외 상황을 만들기 어렵다. 데이터 베이스를 직접 변경해가면서 테스트를 진행해야하기 때문이다. 이러한 과정이 개발 시간을 증가시킨다.

실행 과정에서 에러가 발생하면 확인할 코드가 많다.
로직이 복잡할 수록 한 곳이 아닌 여러 곳에 버그가 존재한다.

코드를 작성한 시점과 테스트 시점 간의 차이가 벌어질수록 문제가 발생했을 때 원인을 찾는데 더 긴 시간이 걸린다. 코드를 다시 읽고 분석해야하기 때문이다.

TDD는 기능을 구현하자마자 테스트를 실행한다. 테스트 직전에 코드를 작성했기 때문에 테스트가 실패해도 원인을 빨리찾을 수 있다.

TDD를 진행하면 전체가 아닌 일부 모드만 검증할 수 있다.
전체가 아닌 범위를 좁혀서 한 번에 하나만 집중해서 구현할 수 있게 도와준다.

## 테스트 가능성

모든 코드를 TDD로 만들 필요는 없으며, 개발을 하고 나서 테스트 코드를 작성해도 괜찮다. 중요한 것은 테스트 가능성을 높이는데 있다.

코드를 만들 때 테스트 가능성을 염두에 두면 개발 생산성과 설계 품질을 높일 수 있다.

외부 시스템과 연동해야하는 코드에서는 (예를들어 자동 이체 신청 기능에서 카드 번호가 유효한지 확인하기 등) 테스트를 하기 위해 외부 시스템이 존재해야하고 외부 시스템에 연결할 수 있도록 방화벽도 설정해야한다. 또한 개발 환경에서 사용할 수 있는 각종 파라미터를 외부 업체에서 제공 받아야한다. 이 작업들은 운이 좋지 않으면 며칠씩 걸리기도 한다.

WireMock 같은 테스트용 서버를 만들어서 코드가 원하는 대로 동작하는지 검증할 수도 있지만, 외부 연동 코드를 구현하는데 테스트하는 것 보다 더 많은 시간과 노력이 들 수 있다.

이 경우 외부 연동 코드를 CardValidator 같은 것으로 분리하고 외부 API를 호출하는 대신 CardValidator를 사용하도록 바꾼다. 이렇게 하면 외부 시스템 없이도 테스트할 수 있다.

-> 외부 담당자를 기다릴 필요가 없이 테스트 대상을 검증할 수 있다!

이 과정에서 자연스럽게 코드의 역할이 분리 되었다.

데이터베이스가 API 호출만이 분리 대상이 아니라, 복잡한 계산 로직도 분리할 수 있다.

테스트 가능성을 높이기 위해 노력하자. 테스트 가능성이 높아지면 외부 환경에 대한 의존이 줄어들어 전체가 아닌 일부만 빠르게 테스트할 수 있게 된다.

## 리펙터링을 위한 테스트 작성하기

리팩터링: 동작은 그대로 유지하면서 내부 구조를 바꾸는 기법

리팩터링 전 테스트 코드를 먼저 작성해야 한다. 기존 코드에 테스트 코드를 먼저 만들고 그 다음 리팩터링을 진행하면 리팩터링 후에 코드가 동일하게 동작하는지 검증할 수 있다.

테스트 코드 없이 기존 코드를 먼저 수정하면 부담이 커진다. 하지만 일부 코드를 분리하고 테스트 코드를 만들어낼 수 있다면 과감하게 시도할 필요가 있다.

만일 코드가 복잡하게 얽혀 있어 일부 코드를 분리하기 힘들다면 통합 테스트 작성을 시도해보자.
이 과정은 쉽지 않고 지루하지만, 코드를 수십차례 디버깅하고 분석하면서 해당 코드에 대한 지식을 얻을 수 있다.

> Characterization Test
> 레거시 코드 활용 전략 이라는 책에서 'Characterization Test' 라는 기법 소개 되었다. '기능 특징 묘사 테스트', 소프트웨어가 실제로 어떻게 동작하는지를 기술하는 용도로 사용된다.

> 통합 테스트 코드 작성 경험
> https://www.youtube.com/watch?v=1k_EyJYKzWQ
