# 코드 이해

## 코드 변경

> 코드 이해
> 코드 수정

코드를 읽고 논리 구조를 파악하고 실행 흐름에 따라 상태 변경을 추적해야 한다.

일반적으로 코드를 이해하는 데 개발 시간의 60%를 사용한다고 함

개발 시간을 줄이고 싶다면 코드를 이해하는 시간을 줄여야한다.

코드 이해하는 시간 줄이기 위한 2가지

1. 코드를 제대로 이해할 수 있는 역량
2. 이해하기 쉬운 코드를 작성하는 역량

## 코드 이해 도구

코드가 수천줄 이상 넘어가기 시작하면?
규모가 커지면 복잡도도 올라간다

코드 분석에 도움이 되는 수단

### 시각화 (UML)

- 도형마다 정해지 ㄴ의미가 있어 서로 다르게 해석할 여지를 줄여준다.
- 액티비티 다이어그램 : 코드의 실행 흐름을 이해하는데 도움이 된다. 코드 한줄 한줄 액션을 하나씩 그릴 필요는 없고, 논리적인 단위로 묶어서 표시
- 시퀀스 다이어그램 : 런타임에 구성 요소가 어떻게 상호 작용하는지 이해하는데 도움이 된다. 시간의 흐름에 따르기 때문에 문제 발생 시점이나 동시성 문제 원인을 찾을 때 시퀀스 다이어그램을 주로 사용된다.
- 클래스 다이어그램 : 코드의 정적 구조를 이해할 떄 도움. 도메인 모델을 분석할 때 유용하다.

### 코드 출력

코드를 출력하여 종이에서 보면서 분석하자. 스크롤보다 더 많은 코드를 볼 수 있고 분석할 수 있다.

- 관심있는 코드, 한 메서드 내에서 값이 변하는 변수, 데이터베이스 연동 코드 등을 형광펜으로 칠한다.
- 서로 영향을 주는 코드들은 서로 선을 긋는다. (의존 그래프)

### 스크래치 리팩터링

- 리팩터링이 외부 기능 동작 변경 없이 내부 구조를 재구성하는 기법이라면, 스크래치 리팩터링은 코드 분석을 목적으로 한다.
- 리팩터링을 하려면 코드 구조나 의미를 이해하는 과정을 거쳐야하는데 스크래치 리팩터링은 여기에 집중한다. (변수 이름 변경, 메서드 추출, 클래스 추출, 파라미터 타입 변경)
- 스크래치 리팩터링은 코드 개선이 아닌 이해가 목적이므로 리팩터링한 결과는 반영하지 않는다.

### 함께 모여 보기

- 코드에 대한 지식이 여러 명에게 쌓인다.
- 서로의 지식을 주고받으며 부족한 부분을 채울 수 있다.
- 잘못 이해하는 것을 줄일 수 있다.

서로 알고있는 지식이 다르므로 코드를 분석하는 과정에서 상호 보완이 된다. 코드를 잘못 이해하는 오류도 줄어든다. (2~4명 정도가 적당)

## 이해하기 좋은 코드

코드를 잘 이해하는 것 이상으로 코드 자체를 이해하기 쉽게 만드는 것이 중요하다.

- 가독성 : 어색한 번역 투나 맞지 않은 단어를 상요하지 말자.

책 추천

- 켄드 벡의 구현 패턴
- 클린 코드 (이 책에서 말하는 내용을 그대로 적용하면 안되고 왜 이런 규칙을 만들었는지 알고 상황에 맞춰 유연하게 적용해야함)

### 이해를 돕는 몇 가지 코드 작성법

#### 이름

- 의미나 의도, 목적을 유추할 수 있는 이름을 사용하자. 이름과 다르게 동작하는 코드를 만들면 잘못 유추할 수 있다.
- 변수를 사용하는 블록이 짧다면 무엇을 의미하는지 쉽게 유추할 수 있기 때문에 괜찮다.
- 사용 범위가 넓다면 서술적인 이름을 사용해야한다.
- 클래스 이름과 달리 필드 이름은 짧아도 의미가 잘 전달된다. (Member 클래스에 포함된 필드 이름이 memberName일 필요는 없다. 그냥 name을 사용해도 회원 이름이라는 것을 알 수 있다.)

#### 중첩 if 최소화

- if 문이 중첩되어 코드가 복잡할 때는 if 조건을 역으로 바꿔 코드 구조를 단순화할 수 있다. (early return)

#### 변수 줄이기

- 변수를 선언한 위치와 변수를 실제로 사용하는 위치가 많이 떨어져 있을 경우, 메서드 시작 부분에 선언한 변수가 언제 어떻게 사용되는지 확인하려면 전체 코드를 탐색해야한다. 중간에 변수를 변경하는 코드가 존재한다면 코드 추적은 더 어려워진다.

- 같은 변수를 서로 다른 용도로 사용할 때, 예를 들어 result 변수에 성공/실패를 저장하는 용도로 사용한다면 result가 어디서 사용되는지에 따라 의미가 달라지므로 코드 분석을 어렵게 만든다. 단순히 타입이 같다는 이유 때문에 1개의 변수를 여러 의미로 사용하지 말자.

- 변수가 사용되는 범위가 넓거나 변수 개수가 많을 때, 또 변수 변ㄴ경이 빈번한거나 변수 용도가 중간에 바뀔 때 코드 분석 과정에서 기억해야할 내용이 많아져 인지 부하 증가로 이어진다. 변수로 인한 인지 부하를 낮추려면 변수 자체를 줄여야한다.

```java
String name = any.getName();
String id = any.getId();

Summary ret = Summary.builder().name(name).id(id).build();
```

```java
Summary ret = Summary.builder().name(any.getName()).id(any.getId()).build();
```

- 이렇게 변수를 새로 정의해서 얻을 수 있는 이점은 없고 인지 부하만 증가시키는 변수가 과연 필요한지 고민해야한다. 필요하지 않다면 변수를 없애고 직접 값을 사용하자.

```java
// 변수 없이 계산식을 전달
checkLimit(thisYear - mem.getBirthYear());

// 계산한 결과를 age 변수에 담아 전달
int age = thisYear - mem.getBirthYear();
checkLimit(age);
```

- 이 경우에는 age 변수를 사용하는 두 번째 코드에서 의미를 더 쉽게 유추 가능

> 변수 사용 범위는 최대한 좁게
> 변수 사용 규칙을 정해 범위를 정하자
>
> 1. 사용되기 직전에 정의
> 2. 짧은 루프 블록 안으로 한정
> 3. 짧은 if-else 블록 안으로 한정
> 4. 짧은 메서드로 한정

- 만약 특정 블록에서만 사용하는 변수가 블록 밖에서 선언되었다면 블록 수행이 끝난 후에도 해당 변수가 사용되고 있는 확인해야한다. (ex. for 블록 안에서만 사용하는 변수의 경우 for 안에서 선언하기)

#### 값 변경 최소화하기

- 변숫값이 중간에 계속 바뀌면 값을 추적해야하는 부담이 생긴다. 특히 if 조건절에서 사용되는 변수가 중간에 변경된다면 코드 추적이 어려워진다.

```java
StringBuilder sb = new StringBuilder("hello");
String s1 = sb.append(" world").toString();
String s2 = sb.append(" world").toString();

System.out.println(s1); // "hello world"
System.out.println(s2); // "hello world world"
```

변수가 담고있는 값 혹은 변수가 참조하는 객체, 구조체의 값이 바뀌면 코드를 분석할 때 부담이 증가한다.

const나 final 같은 키워드를 사용하면 변수가 바뀌지 않는다는 것을 보장할 수 있다.
자바 레코드 타입이나 코틀린의 데이터 클래스를 사용하면 불변 객체를 쉽게만들 수 있다.
모든 객체를 불변 객체로 만들 필요는 없지만, 코드를 분석할 때 값을 추적해얗나느 부담을 줄일 수 있다.

> 💡 불변 객체를 사용하는 성능에 문제가 생길 수 있을까?
> 불변 객체를 사용하면 데이터 변경이 필요할 때 매번 새로운 객체를 생성한다.
> 데이터를 변경하지 않고 매번 새로운 객체를 생성하면 더 많은 메모리를 사용하게 되고, GC는 객체를 정리하는데 더 많은 시간을 쓰게된다. 그렇다면 "불변 객체를 사용하면 성능에 문제가 생기지 않을까?"
> NO! 높은 성능을 요구하는 시스템이 아닌 일반적인 시스템에서 불변객체를 사용한다고 해서 성능에 큰 문제가 생기지 않는다. 또한 GC도 개선되어 GC로 발생하는 응답 지연 시간이 줄어들고 있다.
> 걱정이 된다면 부하테스트 수행해서 측정하자.

#### 알맞은 파라미터 타입 사용하기

아래와 같이 세 메서드의 파라미터를 모두 같게 한다면 타입을 매번 새로 만들지 않아도 되기 때문에 편하다고 생각할 수 있다.
하지만 이 방식은 코드 분석을 어렵게 만든다. 각 메서드가 필요로하는 파라미터가 무엇인지 정확히 알 수 없다.
리팩토링도 힘들어진다. 해당 타입을 사용하는 모든 코드를 확인해야하기 때문이다.
필요한 값만을 파라미터로 전달해야한다.

```java
public void save(MemberDto m){
    ...
}

public void update(MemberDto m){
    ...
}

public void setPassword(MemberDto m){
    ...
}

```

> 개발 생산성과 Map
> Map<String, Object> 형태로 데이터를 전달하는 방식을 채택
> 예: Map<String, Object> userData = new HashMap<>();

> 장점: 유연성: 새로운 필드 추가 시 클래스 변경 없이 Map에 키-값 추가
> 단점: 타입 안전성 부족(컴파일 타임에 오류 검출 안됨), 가독성 저하, 유지 보수 어려움, IDE 도움 받을 수 없음

#### 길지 않은 코드와 메서드 추출

- 모든 구현을 한 메서드에 담지 않고 추출하자 (저장 메소드 내의 검증 메소드를 추출)

#### 추상화 수준 맞추기

코드를 읽는 도중에 다른 메서드로으 이동이 잦다보면 코드를 분석하는 흐름이 끊어진다. 그래서 한 메서드의 모든 로직을 구현하는 개발자도 있지만 코드가 어느 수준 이상으로 길어지면 코드 분석이 힘들어진다.

개념적 단위로 코드를 묶어서 표현한다. 개념적으로 구분되는 로직의 구현 코드를 적절한 이름을 가진 별도으 메서드로 분리하자.

자세하면 더 좋은 메서드 이름일까?
checkSameIdExists -> checkSameIdCountIsOverZero (같은 ID가 존재하는 것을 어떻게 검사하는지 표현)

이것도 나쁘지 않은데, 추상화 수준이 다르다면 다른 뜻으로 이해할 수 있다.
코드를 이해하고 나서야 '같은 ID가 존재하는지 검사한다'로 해석할 수 있게 된다.
최대한 한 메서드 내에서는 추상화 수준을 맞추려고 노력해야한다.
