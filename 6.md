# 리팩터링

## 수정 공포와 변경 비용

> 레거시에 대한 정의
> 오래된 하드웨어에서만 동작하거나 현재는 사용되지 않은 기술로 만들어진 시스템
> 최신 하드웨어에서 동작하지 않거나 새로운 기술을 적용하기 어렵다.
> 완전히 새로 만들어야 레거시 시스템을 변경할 수 있다.

> 테스트 없는 코드
> 이전 버전의 프레임워크를 사용해서 개발한 코드

> 공통점: 레거시는 수정하기 어렵다.

왜 레거시에 부담을 느낄까?

- 긴 클래스, 긴 메서드
- 복잡한 코드
- 이상한 이름
- 많은 중복
- 테스트 코드 없음

이런 특징들이 수정을 어렵게 만들기 때문이다.

코드를 분석하는데 많은 노력이 들어가고, 코드 추적을 어렵게 만든다.

-> 잘 동작하는 코드를 건들지 않고 기존 코드에 새 코드를 덧대는 방식으로 처리하게 된다. (예를들어 is-else 블록 안에 새로운 if-else 블록을 중첩하는 방식으로...)

레거시는 폄하의 대상은 아니다.
레거시가 있었기에 서비스가 굴러가고 수익이 난 것이다. 모든 코드에는 나름의 사정이 있다.
"개선할 거리가 있다면 해보자!"

-> 그러나 개인적으로 이것은 회사의 분위기에 따라서 될 수도 있고 안될 수도 있다고 생각한다.

## 리팩터링

외부로 드러나는 동작이나 기능을 변경하지 않고 내부 구조를 변경해서 재구성하는 기법

겉으로 드러나는 이점이 없지만 장기적 관점에서 이점이 생긴다.

코드 가독성이 높아지고 리팩터링 이전보다 구현 변경과 확장이 용이해진다.

마틴 파울러 '리팩터링 2판'

> 리팩터링과 테스트
> 코드를 수정할 때마다 수동으로 확인하다보면 시간이 오래걸리고 특정 조건에서의 검증을 놓치기 쉽다. 따라서 테스트 코드를 사용해서 검증하는게 좋다.
> 경우에 따라 코드를 수정하지 않고서는 테스트 코드를 만들 수 없을 때도 있다. 테스트 코드 없이 리팩터링을 하면 부담될 것이다. 하지만 리팩터링을 하지 않는 것보다 하는게 낫다. 테스트 코드를 만들지 못해도 리팩터링을 시도해야한다. 현재의 위험을 회피하다보면 미래에 더 큰 위험을 다가오기 때문이다.

### 미사용 코드 삭제

주석 처리된 코드

만일 왜 주석처리 했는지 모르는 경우에는 아래와 같이 TODO 주석을 추가

```
// TODO 삭제 대상 2025-08-17 사용하지 않음
// someDeletingCode
```

TODO 주석을 추가한 날짜를 같이 적어두면 이후에 삭제할 때 도움이 된다. TODO를 검색한 다음에 6개월이 지났다면 사용하지 않는 것이 확실하니 결정을 내리기 쉽다.

사용하지 않는 파라미터, 사용하지 않는 메서드, 사용하지 않는 클래스 모두 삭제 대상이다.

> 미사용 코드 삭제 시 주의사항
> 메서드와 클래스를 삭제할 때는 리플렉션으로 접근하는 코드인지 확인해 봐야 한다. 예를 들어 런타임에 호출할 객체와 메서드 이름을 데이터베이스에 저장하는 시스템이 있다고 해보자. 이런 시스템에서는 소스파일만 뒤져서 해당 클래스를 사용하는 위치를 찾아내기 어렵다. 실수로 리플렉션으로 사용하고 있는 코드를 지우면 런타임에서 클래스나 메서드를 찾을 수 없다는 에러가 발생하는데 이 에러를 확인하고 나서야 사용하고 있는 코드를 지웠다는 사실을 알게된다.

> 리플렉션(Reflection)은 프로그램이 실행 중에 자기 자신의 구조(클래스, 메서드, 필드 등)를
> 조사하고 수정할 수 있는 기능입니다.

> 예를 들어:

> - 문자열로 된 클래스명으로 실제 클래스 객체를 생성
> - 문자열로 된 메서드명으로 메서드를 호출
> - 런타임에 객체의 필드값을 동적으로 접근/수정

```java
  // 일반적인 호출
  MyClass obj = new MyClass();
  obj.myMethod();

  // 리플렉션을 통한 호출
  Class<?> clazz = Class.forName("MyClass");
  Object obj = clazz.newInstance();
  Method method = clazz.getMethod("myMethod");
  method.invoke(obj);
```

### 매직 넘버

```java
if (NumberUtils.anyMatch(boilerType, 19, 20)){
    return true
}
```

여기서 19와 20은 무엇을 의미할까?

```java
if (NumberUtils.anyMatch(boilerType, GAS_BOILER, INDUSTRIAL_BOILER)){
    return true
}
```

가스 보일러, 산업용 보일러일 경우에 true를 리턴한다는 것을 알 수 있다. 코드 의미가 더 잘 드러난다.

실제 값이 궁금한 경우도 있으므로 이름에 코드 값을 함께 쓰는 경우도 있다.

```
public enum BoilerType{
    GAS_19(19), INDUSTRIAL_20(20)
}
```

### 이름 변경

```java
    List<Input> inputs = selectInput(inputList);
```

위 코드는 사실 DB에 데이터를 저장하고 있다고 한다면, 아래와 같이 바꾸는 것이 메서드 내용을 유추하기 쉽다.

```java
    List<Input> inputs = saveInput(inputList);
```

만일 너무 많은 의미가 생략된다면 아래와 같이 이름이 더 길어져도 차라리 긴 이름을 사용하는 것이 낫다.

```java
    List<Input> inputs = filterAndSaveSuccessInput(inputList);
```

번역기와 GPT에게 물어보는 방법도 좋다.

### 매서드 추출

메서드 추출을 사용하면 코드 가독성과 응집도가 높아진다.

메서드 추출하기 좋은 대상은 if-else 블록에 있는 코드이다.

if 블록은 검사를 하지 않았을 때 noCheck를 수행하고, else 블록은 검사했을 때의 로직을 수행한다고 가정해보자.

```java
if(req.isNoCheck()){
    // 긴 코드
}else{
   // 긴 코드
}
```

아래와 같이 코드를 묶어서 메서드로 추출하면 가독성이 좋아지며, 관련 코드가 한 메서드에 모이면서 코드도 더 응집된다.

```java
if(req.isNoCheck()){
    changeBurnerToNoCheck(burner);
}else{
    updateBurnerCheckResult(burner, req);
}
```

그런데 계속 하다보면 코드가 길든 짧든 계속 메서드를 추출하고 싶어진다 😂
가독성이나 응집도가 좋아지는 방향으로 메서드를 추출해야한다.

만약에 코드를 자연스럽게 읽을 수 있다면 적정선에서 메서드 추출을 멈춰도 괜찮다.

### 클래스 분리

한 클래스에 많은 기능이 모여있으면 각 기능을 별도 클래스로 분리한다.

기능을 분리할 때는 한 번에 다 하기보다 한 기능씩 점진적으로 진행한다.

```java
public class MemberService{
    private MemberRepository repository;

    public void create(CreateRequest req){
        ...
        repository.save(member);
    }

    ... 메서드 많음
}
```

아래와 같이 분리할 수 있다.

```java
public class CreateMemberService{
    private MemberRepository repository;

    public void create(CreateRequest req){
        ...
        repository.save(member);
    }
}
```

### 메서드 분리

```java
public void saveContractCancel(CancelDto dto){
    if(dto.getConfirmYn().equals('Y')){
        취소 확정 로직
    }else  if(!dto.getConfirmYn().equals('Y')){
        취소 완료 로직
    }

      if(dto.getConfirmYn().equals('Y')){
        취소 확정 관련 후처리 로직
    }
}
```

취소 확정과 취소 완료라는 서로 다른 기능을 구현하고 있다. if-else가 곳곳에 생겨 코드가 복잡해지고 실행 흐름 추적이 어려워진다.

이런 경우에는 각 기능을 구현하는 메서드를 따로 만들고 분리해서 기능별로 응집도를 높여야한다. saveCancelConfirm(), saveCancelComplete()

#### 메서드 분리 순서

1. 두 기능 중 한 기능을 위한 메서드를 추가한다. 이 메서드는 내부에서 기존 메서드를 호출한다.
2. 기존 메서드를 호출하는 코드가 새 메서드를 호출하도록 변경한다.
3. 기존 메서드의 코드를 새 메서드로 이동한다.
4. 이름을 변경한다.
5. 코드를 정리한다.

### 파라미터값 정리

메서드에서 사용하지 않는 파라미터 데이터는 제거해야한다.
파라미터의 특정 값이 실제로 사용되는지 확인하려면 메서드 자체와 그 메서드가 같은 파라미터를 사용해서 호출하는 메서드까지 흐름에 따라 모든 코드를 뒤져야한다.

-> 수정과 삭제가 쉽다.

#### 파라미터값 정리

여러 메서드에서 한 타입을 파라미터로 사용하고 있다면, 메서드마다 알맞은 파라미터 타입을 추가한다.

1. 메서드 상단에 새 타입을 사용한 객체 생성
2. 메서드가 새 타입 객체를 사용할 때 까지 다음을 반복
   2-a. 메서드에서 사용하는 파라미터 프로퍼티를 새 타입 객체에 추가
   2-b. 메서드에서 새 타입 객체의 프로퍼티를 사용하도록 변경
3. 새 타입 객체를 생성하는 부분을 뺀 나머지를 별도 public 메서드로 추출
4. 메서드 호출을 인라인 처리
5. 과정 3에서 추출한 메서드 이름을 원래 메서드 이름으로 변경

### for에서 하는 2가지 일 분리

하나의 for문에서 한 번에 여러 일을 처리하고 싶을 때, for 문을 두번 실행하는 것보다 한번만 실행하는게 효율적으로 느껴지기도 한다.

하지만 하나의 for문에서 여러 가지 작업을 실행하면 서로 다른 목적을 가진 코드가 뒤섞일 수 있다. 코드 복잡도가 증가하고 코드를 이해하기 어려워진다.

for문이 복잡해지지 않게 방지하는 방법의 하나는 for 루프가 1개의 일만 하도록 수정하는 것이다.

이렇게 했을 때 장점

- 코드가 복잡해지지 않고 논리적인 단위로 구분된다.
- 논리적 단위로 구분되어 코드를 이해하기 쉽다.
- 메서드 추출과 같은 리팩터링이 용이하다.
- 다른 로직을 추가하기 용이하다.

루프를 한 번만 돌면 되는데 여러 번 돌게되면 성능이 느려진다?
-> 미리 걱정하지 말고 정말로 문제가될 때만 측정해서 개선하면 된다.
복잡한 코드보다 이해하기 좋은 코드가 주는 이점이 훨씬 크다.

## 리팩터링 vs 새로만들기

코드 품질을 개선하는 방법 중 하나는 새로 만드는 것이다.

새로 만드는 방법 중 하나는 일부 기능을 마이크로서비스로 분리하는 것이다.

일부 기능만 새로 만들기 때문에 전체를 새로 만드는 것보다 위험 부담이 적다.

단, 프로세스가 분리되기 때문에 데이터 동기화나 통신 실패 같은 기존에 겪지 않았던 다른 문제에 직면할 수 있다.

또한 새로 만든다고 코드가 좋아진다는 법은 없다. 좋은 코드를 만드는 방법을 알아야 코드 품질이 좋아진다.
